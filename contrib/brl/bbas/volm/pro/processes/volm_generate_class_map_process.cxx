// This is brl/bbas/volm/pro/processes/volm_generate_class_map_process.cxx
#include <bprb/bprb_func_process.h>
//:
// \file
//         Take a color classification map generated by sdet classifier and generate corresponding volm land id map
//
//
#include <bprb/bprb_parameters.h>
#include <vil/vil_image_view.h>
#include <volm/volm_category_io.h>

//:
//  Take a colored segmentation output and map it to volm labels
bool volm_generate_class_map_process_cons(bprb_func_process& pro)
{
  vcl_vector<vcl_string> input_types;
  input_types.push_back("vil_image_view_base_sptr");  // classification image
  vcl_vector<vcl_string> output_types;
  output_types.push_back("vil_image_view_base_sptr"); // output unsigned short image with volm_land_type ids
  return pro.set_input_types(input_types)
      && pro.set_output_types(output_types);
}

//: Execute the process
bool volm_generate_class_map_process(bprb_func_process& pro)
{
  if (pro.n_inputs() < 1) {
    vcl_cout << "volm_map_osm_process: The number of inputs should be 1" << vcl_endl;
    return false;
  }

  // get the inputs
  vil_image_view_base_sptr img_sptr = pro.get_input<vil_image_view_base_sptr>(0);
  vil_image_view<vil_rgb<vxl_byte> > img(img_sptr);
  vil_image_view<unsigned short> out_img(img_sptr->ni(), img_sptr->nj(), 1);
  out_img.fill(0);

  vcl_map<vcl_pair<vxl_byte, vcl_pair<vxl_byte, vxl_byte> >, unsigned short> sdet_color_map;
  sdet_color_map[vcl_pair<vxl_byte, vcl_pair<vxl_byte, vxl_byte> >(52, vcl_pair<vxl_byte, vxl_byte>(226, 127))] = 15; // volm_category_io::volm_land_table - "building";
  sdet_color_map[vcl_pair<vxl_byte, vcl_pair<vxl_byte, vxl_byte> >(254, vcl_pair<vxl_byte, vxl_byte>(17, 199))] = 242; // "palm_tree";
  sdet_color_map[vcl_pair<vxl_byte, vcl_pair<vxl_byte, vxl_byte> >(185, vcl_pair<vxl_byte, vxl_byte>(242, 86))] = 0; //"invalid";  // actually park/open in sdet but we're mapping to invalid in volm
  sdet_color_map[vcl_pair<vxl_byte, vcl_pair<vxl_byte, vxl_byte> >(20, vcl_pair<vxl_byte, vxl_byte>(166, 41))] = 31; // "road"; // actually parking_lot in sdet
  sdet_color_map[vcl_pair<vxl_byte, vcl_pair<vxl_byte, vxl_byte> >(191, vcl_pair<vxl_byte, vxl_byte>(184, 98))] = 31; // "road";
  sdet_color_map[vcl_pair<vxl_byte, vcl_pair<vxl_byte, vxl_byte> >(225, vcl_pair<vxl_byte, vxl_byte>(36, 147))] = 0; // "invalid"; // actually shadow in sdet
  sdet_color_map[vcl_pair<vxl_byte, vcl_pair<vxl_byte, vxl_byte> >(116, vcl_pair<vxl_byte, vxl_byte>(45, 119))] = 31; //"road"; // actually street in sdet
  sdet_color_map[vcl_pair<vxl_byte, vcl_pair<vxl_byte, vxl_byte> >(41, vcl_pair<vxl_byte, vxl_byte>(234, 166))] = 243; //"tree"; 
  
  for (unsigned i = 0; i < img.ni(); i++) 
    for (unsigned j = 0; j < img.nj(); j++) {
      vcl_pair<vxl_byte, vcl_pair<vxl_byte, vxl_byte> > pp(img(i,j).r, vcl_pair<vxl_byte, vxl_byte>(img(i,j).g, img(i,j).b));
      vcl_map<vcl_pair<vxl_byte, vcl_pair<vxl_byte, vxl_byte> >, unsigned short>::iterator iter = sdet_color_map.find(pp);
      if (iter != sdet_color_map.end())
        out_img(i, j) = iter->second;
      else
        out_img(i, j) = 0;  // map to invalid if undefined
    }
    
  

  vil_image_view_base_sptr out_img_sptr = new vil_image_view<unsigned short>(out_img);
  pro.set_output_val<vil_image_view_base_sptr>(0, out_img_sptr);
  return true;
}
