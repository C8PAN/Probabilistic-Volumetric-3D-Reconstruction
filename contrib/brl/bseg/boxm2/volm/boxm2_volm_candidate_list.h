// This is brl/bseg/boxm2/volm/boxm2_volm_candidate_list.h
#ifndef boxm2_volm_candidate_list_h_
#define boxm2_volm_candidate_list_h_
//:
// \file
// \brief A class to create candidate list from probablity map generated by volm_matcher
//
// \author Yi Dong
// \date April 17, 2013
// \verbatim
// Modifications
//  <none yet>
// \endverbatim


#include <vgl/vgl_polygon.h>
#include <vil/algo/vil_find_4con_boundary.h>
#include <vcl_functional.h>
#include <vcl_map.h>
#include <volm/volm_io.h>
#include <volm/volm_tile.h>
#include <volm/volm_camera_space.h>
#include <vil/vil_image_view.h>
#include <vgl/vgl_polygon.txx>
#include <vgl/algo/vgl_convex_hull_2d.h>

typedef vcl_multimap<unsigned, vgl_point_2d<int>, vcl_greater<unsigned> > mymap;

#if 0
//: a class use to rearrange the points in counterclock wise
class c_less
{
public:
  c_less() : cent_(vgl_point_2d<double>(0.0,0.0)) {}
  c_less(vgl_point_2d<double> const& center) : cent_(center) {}
  ~c_less() {}
  // the predicate function
  bool operator() (vgl_point_2d<double> const& pa, vgl_point_2d<double> const& pb) const
  {
    if (pa.x() >=0 && pb.x() < 0)
      return false;
    if (pa.x() == 0 && pb.x() == 0)
      return pa.y() < pb.y();
    // compute the cross product of vector (cent-a) x (cent-b) to define the counter-clock order
    double det = (pa.x()-cent_.x())*(pb.y()-cent_.y()) - (pb.x()-cent_.x())*(pa.y()-cent_.y());
    if (det < 0)
      return false;
    if (det > 0)
      return true;
    // if det == 0, pa and pb are colinear and check which point is closer than the center 
    double da = (pa.x() - cent_.x())*(pa.x() - cent_.x()) + (pa.y() - cent_.y())*(pa.y() - cent_.y());
    double db = (pb.x() - cent_.x())*(pb.x() - cent_.x()) + (pb.y() - cent_.y())*(pb.y() - cent_.y());
    return da < db;
  }
private:
  vgl_point_2d<double> cent_;
};
#endif

class boxm2_volm_candidate_list
{
  public:
    //: default consturctor
    boxm2_volm_candidate_list() {}
    //: constructor
    boxm2_volm_candidate_list(vil_image_view<vxl_byte> const& image,
                              unsigned threshold);
    //: destructor
    ~boxm2_volm_candidate_list() {}
    
    //: accessors
    vgl_polygon<int> cand_poly() { return poly_; }
    unsigned threshold()         { return thres_; }
    
    //: number of sheets in candidate list
    unsigned num_of_regions() { return n_sheet_; }
    //: best score for each sheet
    bool region_score(vcl_vector<unsigned>& scores);
    //: return the top pixel which has highest scores
    bool top_locations(vcl_vector<vcl_vector<vgl_point_2d<int> > >& top_locs, vcl_vector<vcl_vector<unsigned> >& top_loc_scores);
    //: for each sheet, return top number of pixels which have high scores
    bool top_locations(vcl_vector<vcl_vector<vgl_point_2d<int> > >& top_locs, vcl_vector<vcl_vector<unsigned> >& top_loc_scores, unsigned const& size);
    //: return the top number of pixels which have highest scores, for sheet sh_idx
    bool top_locations(vcl_vector<vgl_point_2d<int> >& top_locs, vcl_vector<unsigned>& top_loc_scores, unsigned const& size, unsigned const& sh_idx);
    //: return the top number of locs which have highest scores, for sheet sh_idx
    bool top_locations(vcl_vector<vgl_point_2d<double> >& top_locs, vcl_vector<unsigned>& top_loc_scores, volm_tile& tile, unsigned const& size, unsigned const& sh_idx);
    //: create an image with candidate region highlighted
    bool candidate_list_image(vil_image_view<vxl_byte>& image);
    //: transfer the region coordinates from image to global, returned points vector are the polygon for kml
    bool img_to_golbal(unsigned const& sh_idx, volm_tile& tile, vcl_vector<vgl_point_2d<double> >& region_global);
    //: find the region where the given location is in
    bool find(unsigned const& i, unsigned const& j, unsigned& sh_idx, unsigned& loc_score);
    bool find(vgl_point_2d<unsigned> const& loc, unsigned& sh_idx, unsigned& loc_score)
    {
      return this->find(loc.x(), loc.y(), sh_idx, loc_score);
    }
    bool find(double const& lon, double const& lat, volm_tile& tile, unsigned& sh_idx, unsigned& loc_score)
    {
      unsigned u, v;
      if (!tile.global_to_img(lon, lat, u, v))
        return false;
      return this->find(u, v, sh_idx, loc_score);
    }
    //: write the header of the kml
    static void open_kml_document(vcl_ofstream& str, vcl_string const& name, float const& threshold);
    //: close the document
    static void close_kml_document(vcl_ofstream& str);
    //: write a region into kml
    static void write_kml_regions(vcl_ofstream& str,
                                  vcl_vector<vgl_point_2d<double> >& region,
                                  vcl_vector<vgl_point_2d<double> >& top_locs,
                                  vcl_vector<cam_angles>& camera,
                                  vcl_vector<double>& right_fov,
                                  float const& likelihood,
                                  unsigned const& rank);
    
    
  
  private:
    unsigned thres_;
    unsigned n_sheet_;
    vil_image_view<vxl_byte> image_;
    //: pixels that have values larger than thres_
    mymap pt_map_;
    //: candidate list polygon for current image
    vgl_polygon<int> poly_;
    //: check whether the pixel is inside the candidate poly
    bool contains(vcl_vector<vgl_point_2d<int> > const& sheet, unsigned const& i, unsigned const& j);
    
};

#endif
